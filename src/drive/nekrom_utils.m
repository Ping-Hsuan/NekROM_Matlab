%#####################################
%
%# Matlab Utilities for NekROM
%# v0.0.0
%
%# Ping-Hsuan Tsai
%# 2022-12-28
%
%#####################################

classdef nekrom_utils
   methods ( Static = true )
      function load_ops(ifrom,ifcopt,path)
      % The function load_ops is used to load the ROM operator
      % generated by NekROM

         fprintf('Loading ROM operators and vectors... \n');
         fprintf('Currently only support velocity... \n');

         global nb mb;
         mb=dlmread(path+"nb");

         index  = [1:nb+1];
         index1 = [1:nb];

         if ifrom(1)

            global au0 bu0 cu u0;
            global au bu;
            global u ua u2a ru eu hufac;

            % load stiffness matrix
            a0_full = dlmread(path+"au");
            a0_full = reshape(a0_full,mb+1,mb+1);
            au0     = a0_full(index,index);

            % load mass matrix
            b0_full = dlmread(path+"bu");
            b0_full = reshape(b0_full,mb+1,mb+1);
            bu0     = b0_full(index,index);

            % load advection tensor
            cu_full = dlmread(path+"cu");
            cu_full = reshape(cu_full,mb,mb+1,mb+1);
            cu      = cu_full(index1,index,index);
            cu      = reshape(cu,nb*(nb+1),nb+1);

            % load initial condition
            u0_full = dlmread(path+"u0");
            u0      = u0_full(index);

            au = au0(2:end,2:end);
            bu = bu0(2:end,2:end);

            ms = dlmread(path+"ns");
            if ifcopt
               uk_full = dlmread(path+"uk");
               uk_full = reshape(uk_full,mb+1,ms);
               global uk;
               uk = uk_full(index,:);
            end
            if ifcopt
               global ukmin ukmax
               ukmin = min(uk,[],2);
               ukmax = max(uk,[],2);
            end
         end

         u     = zeros(nb+1,3);
         ua    = zeros(nb+1,1);
         u2a   = zeros(nb+1,nb+1);
         ru    = zeros(nb,1);
         eu    = zeros(nb,3);
         hufac = [];

         if ifrom(2)
            global at0 bt0 ct;
         end

         if ifrom(1); u(:,1)=u0; end
         if ifrom(2); t(:,1)=t0; end

         global ifdrag;
         global fd1 fd3 rdgx rdgy rdgz;
         if ifdrag
            fd1  = dlmread("./qoi/fd1");
            fd3  = dlmread("./qoi/fd3");
            fd3= reshape(fd3,2,mb+1);
            rdgx = dlmread("./qoi/rdgx");
            rdgy = dlmread("./qoi/rdgy");
         end

         fprintf("done loading ... \n");
         
      end

      function readconf(fname)
      % The function readconf is used to read configuration parameters
      % Notice that fname has to be in json format

         global nsteps iostep astep dt nb nu ips;
         global ifrom ifleray ifefr ifcopt ifdrag iftr;
         global filterType;
         global dfOrder dfRadius relax;
         global adOrder adRadius

         fname = 'mor.json';
         fid = fopen(fname);
         raw = fread(fid,inf);
         str = char(raw');
         fclose(fid);
         rom = jsondecode(str);
         
         fprintf('[General] \n');
         if isfield(rom,'nsteps')
            nsteps = rom.nsteps;
            fprintf('nsteps: %d \n',nsteps); 
         else
            error('missing nsteps...'); 
         end
         
         if isfield(rom,'iostep')
            iostep = rom.iostep;
            fprintf('iostep: %d \n',iostep); 
         else
            error('missing iostep...'); 
         end
         
         if isfield(rom,'astep')
            astep = rom.astep;
            fprintf('astep: %d \n',astep); 
         else
            astep = 1;
         end
         
         if isfield(rom,'dt')
            dt = rom.dt;
            fprintf('dt: %f \n',dt); 
         end
         
         if isfield(rom,'type')
            ips = rom.type;
            fprintf('type: %s \n',ips); 
         end

         if isfield(rom,'nb')
            nb = rom.nb;
            fprintf('nb: %d \n',nb); 
         end

         ifrom = zeros(2, 1);
         if isfield(rom,'viscosity')
            nu = rom.viscosity;
            fprintf('viscosity: %d \n',nu); 
            if nu < 0.0
               nu = -1.0/nu;
            end
            ifrom(1) = 1;
         end

         fprintf('[QOI] \n');
         if isfield(rom,'ifdrag')
            ifdrag = rom.ifdrag;
            if ifdrag == 1
               fprintf('ifdrag: True \n'); 
            else
               fprintf('ifdrag: False \n'); 
            end
         end

         fprintf('[COPT] \n');
         if isfield(rom,'ifcopt')
            ifcopt = rom.ifcopt;
            if ifcopt == 1
               fprintf('ifcopt: True \n'); 
            else
               fprintf('ifcopt: False \n'); 
            end
         end

         fprintf('[Reg] \n');
         if isfield(rom,'ifleray')
            ifleray = rom.ifleray;
            if ifleray == 1
               fprintf('ifleray: True \n'); 
            else
               fprintf('ifleray: False \n'); 
            end
         end

         if isfield(rom,'filter_type')
            filterType = rom.filter_type;
            fprintf('filterType: %s\n',filterType); 
            if filterType == "cutoff"
               if isfield(rom,'filter_modes')
                  global filterModes;
                  filterModes = rom.filter_modes;
                  fprintf('filterModes: %s\n',filterModes); 
               else
                  error('Filter type requires specifying number of modes to be filters \n');
               end
           elseif filterType == "df_repeat"
               if isfield(rom,'df_order')
                  dfOrder = rom.df_order;
                  fprintf('dfOrder: %d \n',dfOrder); 
               else
                  error('df order not specified \n');
               end
               if isfield(rom,'df_radius')
                  dfRadius= rom.df_radius;
                  fprintf('dfRadius: %f \n',dfRadius); 
               else
                  error('df radius not specified \n');
               end
            elseif filterType == "df"
               if isfield(rom,'df_order')
                  dfOrder = rom.df_order;
                  fprintf('dfOrder: %d \n',dfOrder); 
               else
                  error('df order not specified \n');
               end
               if isfield(rom,'df_radius')
                  dfRadius= rom.df_radius;
                  fprintf('dfRadius: %f \n',dfRadius); 
               else
                  error('df radius not specified \n');
               end
            else
               error('Invalid filter Type')
            end
         end

         if isfield(rom,'ifEFR')
            ifefr = rom.ifEFR;
            if ifefr == 1
               fprintf('ifefr: True \n'); 
            else
               fprintf('ifefr: False \n'); 
            end
            if isfield(rom,'relax')
               relax = rom.relax;
               fprintf('relax: %f \n',relax); 
            else
               error('relaxation parameter not specified \n');
            end
         end

         if isfield(rom,'iftr')
            iftr = rom.iftr;
            if iftr == 1
               fprintf('iftr: True \n'); 
            else
               fprintf('iftr: False \n'); 
            end
            if isfield(rom,'relax')
               relax = rom.relax;
               fprintf('relax: %f \n',relax); 
            else
               error('relaxation parameter not specified \n');
            end
            if isfield(rom,'ad_order')
               adOrder = rom.ad_order;
               fprintf('adOrder: %d \n',adOrder); 
            else
               error('ad order not specified \n');
            end
            if isfield(rom,'ad_radius')
               adRadius= rom.ad_radius;
               fprintf('adRadius: %f \n',adRadius); 
            else
               error('ad radius not specified \n');
            end
         end

         fprintf('\n'); 
      end

      function initvars()
      % The function initvars is used to initialize variables
         global time;
         time = 0.;

         global alphas betas;
         [alphas, betas] = nekrom_utils.setcoef();

         global filterType dfOrder dfRadius
         if filterType == "df"
            global dfHfac au bu;
            dfHfac = [];
            dfHfac = nekrom_utils.set_df(au,bu,dfRadius,dfOrder,dfHfac);
         end

         if filterType == "df_repeat"
            global dfHfac au bu;
            dfHfac = [];
            dfHfac = nekrom_utils.set_df_repeat(au,bu,dfRadius,dfOrder,dfHfac);
         end

         global iftr adHfac adOrder adRadius
         if iftr
            global au bu;
            adHfac = nekrom_utils.set_ad(au,bu,adRadius,adOrder);
         end

      end
      
      function [alphas, betas] = setcoef()
      % Setup BFDk/EXTk coefficients
         alphas=zeros(3,3);
         betas=zeros(4,3);

         alphas(1,1)=  1.0;

         alphas(1,2)=  2.0;
         alphas(2,2)= -1.0;

         alphas(1,3)=  3.0;
         alphas(2,3)= -3.0;
         alphas(3,3)=  1.0;

         betas(1,1)=  1.0;
         betas(2,1)= -1.0;

         betas(1,2)=  1.5;
         betas(2,2)= -2.0;
         betas(3,2)=  0.5;

         betas(1,3)=  11.0/6;
         betas(2,3)= -3.0;
         betas(3,3)=  1.5;
         betas(4,3)= -1.0/3;
      end

      function [rhs,ext] = setr(a,b,c,f,u,t,ext,diff,alphas,betas,dt,ito)
         global ifleray filterType iftr relax dfHfac
         global adHfac

         nb=size(u,1)-1;
         rhs=zeros(nb,1);

         ext(:,3)=ext(:,2);
         ext(:,2)=ext(:,1);
         ext(:,1)=ext(:,1)*0;

         utmp = u;
         if ifleray
%           fprintf('checking ifleray \n')
            if filterType == "cutoff"
               global filterModes
               utmp((nb+1)-filterModes+1:end,1) = 0;
            else
               utmp = [1;(dfHfac\(dfHfac'\utmp(2:end,1)))];
            end
         end
         ext(:,1)=ext(:,1)-reshape(c*utmp(:,1),nb,nb+1)*t(:,1);

         ext(:,1)=ext(:,1)-a(2:end,1)*diff;
         ext(:,1)=ext(:,1)+f;
         if iftr
            % computer filtered u
            utmp = [1;(dfHfac\(dfHfac'\utmp(2:end,1)))];
            ext(:,1) = ext(:,1)-relax*(u(2:end,1)-utmp(2:end));
%           % apply approximated deconvolution
%           ext(:,1) = ext(:,1)-relax*(u(2:end,1)-adHfac*utmp(2:end));
         end

         rhs=rhs+ext*alphas(:,ito);
         rhs=rhs-b*(t(2:end,:)*betas(2:end,ito))/dt;
      end

      function [next,hfac] = step(rhs,a,b,diff,betas,dt,ito,hfac)
         if isempty(hfac)
            h=b*betas(1,ito)/dt+a*diff;
%           h=.5*(h+h');
            hfac=chol(h);
         end
         next = [1,(hfac\(hfac'\rhs))'];
      end

      function a = shift(a,b,n)
         for i=n:-1:2; 
            a(:,i)=a(:,i-1); 
         end
         a(:,1)=b;
      end

      function cdrag(fd1,fd3,rdgx,rdgy,u,nu)
         global time
         nb = size(u,1)-1;
         vdx = rdgx'*u(:,1)*nu;
         vdy = rdgy'*u(:,1)*nu;
         pdx3 = fd3(1,:)*u(:,1)*nu;
         pdy3 = fd3(2,:)*u(:,1)*nu;
         dx = vdx+pdx3;
         dy = vdy+pdy3;

         fprintf("%12.8E %12.8E %12.8E %12.8E \n",time,vdx,pdx3,dx)
         fprintf("%12.8E %12.8E %12.8E %12.8E \n",time,vdy,pdy3,dy)
      end

      function [hfac] = set_df(a,b,dfRadius,dfOrder,hfac)
         % Construct the mth order differential filter (df) 
         % I + (\delta^2 B^{-1}A)^m
         % with radius delta
         if isempty(hfac)
            bfac = chol(b);
            h = (dfRadius^2)*(bfac\(bfac'\a));
            for i=2:dfOrder
              h = h*((dfRadius^2)*(bfac\(bfac'\a)));
            end
            h = h + eye(size(a));
            hfac=chol(h);
         end
      end
      function [hfac] = set_df_repeat(a,b,dfRadius,dfOrder,hfac)
         % Construct 1st order differential filter (df) 
         % and apply repeatedly
         % (I + (\delta^2 B^{-1}A))^m
         % with radius delta
         if isempty(hfac)
            bfac = chol(b);
            h = eye(size(a))+(dfRadius^2)*(bfac\(bfac'\a));
            for i=2:dfOrder
              h = h*(eye(size(a))+(dfRadius^2)*(bfac\(bfac'\a)));
            end
            hfac=chol(h);
         end
      end
      function [ad] = set_ad(a,b,adRadius,adOrder)
         % Construct the mth order approximate deconvolution
         % I + (I-G) + (I-G)^2 + ...
         % where G is a higher-order differential filter
         bfac = chol(b);
         g = (adRadius^2)*(bfac\(bfac'\a));
         g = g + eye(size(a));
%        gfac=chol(g);
         gfac = inv(g);
%        factor = (eye(size(a)))-(gfac\gfac');
         factor = (eye(size(a)))-gfac;

         % Construct approximate deconvolution
         ad = eye(size(a));
%        ad = ad + factor;
%        ad = ad + factor*factor;
%        ad = ad + factor*factor*factor;
         for j=1:adOrder
            tmp = eye(size(a));
            for i=1:j;
               tmp = tmp*factor;
            end
            ad = ad + tmp;
         end
      end
   end
end

